# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/game/engine/00_core.ipynb.

# %% auto 0
__all__ = ['type_to_class_name', 'class_name_to_type', 'GameError', 'OptionError', 'NoToken', 'RouteTooShort', 'RouteTooLong',
           'ReusesCity', 'GameLog', 'Assignable', 'Entity', 'Item', 'Ownable', 'Loan', 'OperatingInfo', 'Operator',
           'Passer', 'SharePrice', 'Share', 'ShareBundle', 'ShareHolder', 'SharePool', 'Spender', 'BaseMovement',
           'TwoDimensionalMovement', 'OneDimensionalMovement', 'ZigZagMovement', 'StockMarket', 'Token', 'Train',
           'Phase']

# %% ../../../nbs/game/engine/00_core.ipynb 5
def type_to_class_name(type_str):
    """Convert a type string to a class name."""
    return "".join(word.capitalize() for word in type_str.split("_"))


def class_name_to_type(cls):
    """Convert a class name to a type string."""
    if not cls:
        return None
    class_name = cls.__name__
    return "".join(["_" + i.lower() if i.isupper() else i for i in class_name]).lstrip(
        "_"
    )

# %% ../../../nbs/game/engine/00_core.ipynb 7
class GameError(RuntimeError):
    pass


class OptionError(RuntimeError):
    pass


class NoToken(GameError):
    pass


class RouteTooShort(GameError):
    pass


class RouteTooLong(GameError):
    pass


class ReusesCity(GameError):
    pass

# %% ../../../nbs/game/engine/00_core.ipynb 10
class GameLog(list):
    def __init__(self, game):
        super().__init__()
        self.game = game

    def append(self, message):
        """Overrides the append method to add a log entry."""
        if not isinstance(message, GameLog.Entry):
            message = GameLog.Entry(message, self.game.current_action_id)
        super().append(message)

    class Entry:
        """A log entry storing a message and an action ID."""

        def __init__(self, message, action_id):
            self.message = message
            self.action_id = action_id

        def __repr__(self):
            """Representation of the log entry."""
            return f"<Entry message='{self.message}', action_id={self.action_id}>"

# %% ../../../nbs/game/engine/00_core.ipynb 13
class Assignable:
    def __init__(self):
        assignments = {}

    def assigned(assignable, key):
        return key in assignments.get(assignable, {})

    def assign(assignable, key, value=True):
        if assignable not in assignments:
            assignments[assignable] = {}
        assignments[assignable][key] = value

    def remove_assignment(assignable, key):
        if assignable in assignments:
            assignments[assignable].pop(key, None)

    def remove_from_all(assignables, key):
        for assignable in assignables:
            if assigned(assignable, key):
                remove_assignment(assignable, key)

# %% ../../../nbs/game/engine/00_core.ipynb 15
class Entity:
    def iscompany():
        return false

    def iscorporation():
        return false

    def isminor():
        return false

    def issystem():
        return false

    def isoperator():
        return false

    def isplayer():
        return false

    def isreceivership():
        return false

    def isshare_pool():
        return false

    def isclosed():
        return false

# %% ../../../nbs/game/engine/00_core.ipynb 17
class Item:
    def __init__(self, description="", cost=0):
        self.description = description
        self.cost = cost

    def __eq__(self, other):
        return self.description == other.description and self.cost == other.cost

# %% ../../../nbs/game/engine/00_core.ipynb 19
class Ownable:
    def __init__(self):
        self._owner = None

    @property
    def owner(self):
        return self._owner

    @owner.setter
    def owner(self, value):
        self._owner = value

    def owned_by(self, entity):
        if not entity:
            return False
        return (
            self._owner == entity
            or getattr(self._owner, "owner", None) == entity
            or self._owner == getattr(entity, "owner", None)
        )

    def player(self):
        if hasattr(self._owner, "player") and callable(getattr(self._owner, "player")):
            return self._owner.player()
        return (
            self._owner
            if hasattr(self._owner, "player") and self._owner.player
            else None
        )

    def corporation(self):
        if self.corporation():
            return self
        return getattr(self._owner, "corporation", None)

    def owned_by_corporation(self):
        return hasattr(self._owner, "corporation") and callable(
            getattr(self._owner, "corporation")
        )

    def owned_by_player(self):
        return hasattr(self._owner, "player") and callable(
            getattr(self._owner, "player")
        )

    def corporation(self):
        return False

# %% ../../../nbs/game/engine/00_core.ipynb 21
class Loan(Ownable):
    def __init__(self, id, amount):
        self.id = id
        self.amount = amount

# %% ../../../nbs/game/engine/00_core.ipynb 23
class OperatingInfo:
    def __init__(self, runs, dividend, revenue, laid_hexes, dividend_kind=None):
        self.routes = {run.train: run.connection_hexes for run in runs}
        self.halts = {run.train: run.halts for run in runs}
        self.nodes = {run.train: run.node_signatures for run in runs}
        self.revenue = revenue
        self.dividend = dividend
        self.laid_hexes = laid_hexes
        self.dividend_kind = dividend_kind or (
            dividend.kind
            if isinstance(dividend, Engine.Action.Dividend)
            else "withhold"
        )

# %% ../../../nbs/game/engine/00_core.ipynb 25
class Operator(Entity):
    def __init__(self, **kwargs):
        super().__init__()
        self.cash = 0
        self.trains = []
        self.operating_history = {}
        self.logo_filename = f"{kwargs.get('logo', '')}.svg"
        self.logo = f"/logos/{self.logo_filename}"
        self.simple_logo = (
            f"/logos/{kwargs.get('simple_logo', '')}.svg"
            if kwargs.get("simple_logo")
            else self.logo
        )
        self.coordinates = kwargs.get("coordinates")
        self.city = kwargs.get("city")
        self.tokens = [
            Token(self, price=price) for price in (kwargs.get("tokens", []) or [])
        ]
        self.loans = []
        self.color = kwargs.get("color")
        self.text_color = kwargs.get("text_color", "#ffffff") or "#ffffff"
        self.destination_coordinates = kwargs.get("destination_coordinates")
        self.destination_exits = kwargs.get("destination_exits")
        self.destination_icon = (
            f"/icons/{kwargs.get('destination_icon', '')}"
            if kwargs.get("destination_icon")
            else ""
        )
        self.destination_loc = kwargs.get("destination_loc")
        self.destination_icon_in_city_slot = kwargs.get("destination_icon_in_city_slot")

    def operator(self):
        return True

    def runnable_trains(self):
        return [train for train in self.trains if not train.operated]

    def operated(self):
        return bool(self.operating_history)

    def next_token(self):
        return next((token for token in self.tokens if not token.used), None)

    def find_token_by_type(self, type=None):
        type = type or "normal"
        return next(
            (token for token in self.tokens if not token.used and token.type == type),
            None,
        )

    def tokens_by_type(self):
        return list(
            {token.type: token for token in self.tokens if not token.used}.values()
        )

    def unplaced_tokens(self):
        return [token for token in self.tokens if not token.city]

    def placed_tokens(self):
        return [token for token in self.tokens if token.city]

# %% ../../../nbs/game/engine/00_core.ipynb 27
class Passer:
    def __init__(self):
        self._passed = False

    @property
    def passed(self):
        return self._passed

    def passed(self):
        return self._passed

    def active(self):
        return not self._passed

    def pass_(self):
        self._passed = True

    def unpass(self):
        self._passed = False

# %% ../../../nbs/game/engine/00_core.ipynb 29
class SharePrice:
    TYPE_MAP = {
        "p": "par",
        "e": "endgame",
        "c": "close",
        "b": "multiple_buy",
        "o": "unlimited",
        "y": "no_cert_limit",
        "l": "liquidation",
        "a": "acquisition",
        "r": "repar",
        "i": "ignore_one_sale",
        "j": "ignore_two_sales",
        "s": "safe_par",
        "P": "par_overlap",
        "x": "par_1",
        "z": "par_2",
        "w": "par_3",
        "C": "convert_range",
        "m": "max_price",
        "n": "max_price_1",
        "u": "phase_limited",
        "t": "type_limited",
        "B": "pays_bonus",
        "W": "pays_bonus_1",
        "X": "pays_bonus_2",
        "Y": "pays_bonus_3",
        "Z": "pays_bonus_4",
    }

    NON_HIGHLIGHT_TYPES = [
        "par",
        "safe_par",
        "par_1",
        "par_2",
        "par_3",
        "par_overlap",
        "safe_par",
        "convert_range",
        "max_price",
        "max_price_1",
        "repar",
        "type_limited",
    ]

    PAR_TYPES = ["par", "par_overlap", "par_1", "par_2", "par_3"]

    def __init__(
        self,
        coordinates,
        price,
        info=None,
        types=None,
        unlimited_types=None,
        multiple_buy_types=None,
    ):
        self.coordinates = coordinates
        self.price = price
        self.type = types[0] if types else None
        self.types = types or []
        self.corporations = []
        self.can_buy_multiple = self.type in (multiple_buy_types or [])
        self.limited = self.type not in (unlimited_types or [])
        self.info = info

    def __eq__(self, other):
        return self.coordinates == other.coordinates

    def id(self):
        return f"{self.price},{','.join(map(str, self.coordinates))}"

    def counts_for_limit(self):
        return self.limited

    def buy_multiple(self):
        return self.can_buy_multiple

    def __str__(self):
        return f"{self.__class__.__name__} - {self.price} {self.coordinates}"

    def can_par(self):
        return self.type in self.PAR_TYPES

    def end_game_trigger(self):
        return self.type == "endgame"

    def liquidation(self):
        return self.type == "liquidation"

    def acquisition(self):
        return self.type == "acquisition"

    def highlight(self):
        return self.type and self.type not in self.NON_HIGHLIGHT_TYPES

    def normal_movement(self):
        return self.type != "liquidation"

    def remove_par(self):
        self.types = [t for t in self.types if t not in self.PAR_TYPES]
        self.type = self.types[0] if self.types else None

# %% ../../../nbs/game/engine/00_core.ipynb 31
class Share(Ownable):
    def __init__(
        self, corporation, owner=None, president=False, percent=10, index=0, cert_size=1
    ):
        super().__init__()
        self.cert_size = cert_size
        self.corporation = corporation
        self.president = president
        self.percent = percent
        self.owner = owner or corporation
        self.index = index
        self.buyable = True
        self.counts_for_limit = True
        self.preferred = False
        self.last_cert = False
        self.double_cert = False

    def id(self):
        return f"{self.corporation.id}_{self.index}"

    def num_shares(self, ceil=True):
        num = self.percent / self.corporation.share_percent
        return math.ceil(num) if ceil else num

    def price_per_share(self):
        share_price = (
            self.corporation.par_price
            if self.owner == self.corporation.ipo_owner
            else self.corporation.share_price
        )
        return (
            share_price.price * self.corporation.price_multiplier
            if share_price
            else self.corporation.min_price
        )

    def price(self):
        return math.ceil(self.price_per_share() * self.num_shares(ceil=False))

    def to_s(self):
        return f"{self.__class__.__name__} - {self.id()}"

    def to_bundle(self, percent=None):
        return ShareBundle(self, percent)

    def __str__(self):
        return f"<Share: {self.corporation.id} {self.percent}%>"

    def common_percent(self):
        return 0 if self.preferred else self.percent

    def transfer(self, new_entity):
        self.owner.shares_by_corporation[self.corporation].remove(self)
        self.corporation.share_holders[self.owner] -= self.percent
        self.owner = new_entity
        self.corporation.share_holders[new_entity] += self.percent
        new_entity.shares_by_corporation[self.corporation].append(self)

# %% ../../../nbs/game/engine/00_core.ipynb 33
class ShareBundle:
    def __init__(self, shares, percent=None):
        if isinstance(shares, list):
            self.shares = shares.copy()
        else:
            self.shares = [shares]

        if not len({share.corporation for share in self.shares}) == 1:
            raise ValueError("All shares must be from the same corporation")

        if not len({share.owner for share in self.shares}) == 1:
            raise ValueError("All shares must be owned by the same owner")

        self.percent = (
            percent
            if percent is not None
            else sum(share.percent for share in self.shares)
        )
        self.share_price = None

    def num_shares(self, ceil=True):
        num = self.percent / self.corporation.share_percent
        return ceil(num) if ceil else num

    @property
    def partial(self):
        return self.percent != sum(share.percent for share in self.shares)

    @property
    def corporation(self):
        return self.shares[0].corporation

    @property
    def owner(self):
        return self.shares[0].owner

    @property
    def president(self):
        return self.corporation.owner

    @property
    def presidents_share(self):
        return next((share for share in self.shares if share.president), None)

    @property
    def preferred(self):
        return any(share.preferred for share in self.shares)

    def price_per_share(self):
        return self.share_price or self.shares[0].price_per_share

    def price(self):
        return ceil(self.price_per_share() * self.num_shares(ceil=False))

    def can_dump(self, entity):
        if not self.presidents_share:
            return True

        sh = self.corporation.player_share_holders(corporate=True)
        return (
            max((v for k, v in sh.items() if k != entity), default=0)
            >= self.presidents_share.percent
        )

    def to_bundle(self):
        return self

    @property
    def buyable(self):
        return all(share.buyable for share in self.shares)

    def __eq__(self, other):
        return (
            self.shares == other.shares
            and self.percent == other.percent
            and self.share_price == other.share_price
        )

    @property
    def common_percent(self):
        return sum(share.percent for share in self.shares if not share.preferred)

# %% ../../../nbs/game/engine/00_core.ipynb 35
class ShareHolder:
    def __init__(self):
        self.shares_by_corporation = {}

    def shares(self):
        return [
            share for shares in self.shares_by_corporation.values() for share in shares
        ]

    def shares_by_corporation(self, sorted=False):
        if sorted:
            self.shares_by_corporation = dict(
                sorted(self.shares_by_corporation.items())
            )
        return self.shares_by_corporation

    def shares_of(self, corporation):
        return self.shares_by_corporation.get(corporation, [])

    def delete_share(self, share):
        self.shares_by_corporation.get(share.corporation, []).remove(share)

    def certs_of(self, corporation):
        return self.shares_of(corporation)

    def percent_of(self, corporation):
        shares = self.shares_by_corporation.get(corporation, [])
        return sum(share.percent for share in shares)

    def common_percent_of(self, corporation):
        shares = [
            share
            for share in self.shares_by_corporation.get(corporation, [])
            if not share.preferred
        ]
        return sum(share.percent for share in shares)

    def presidencies(self):
        return [
            corporation
            for corporation, shares in self.shares_by_corporation.items()
            if any(share.president for share in shares)
        ]

    def num_shares_of(self, corporation, ceil=True):
        percent = self.percent_of(corporation)
        num = percent / corporation.share_percent
        return int(num) if ceil else num

# %% ../../../nbs/game/engine/00_core.ipynb 37
class SharePool(Entity, ShareHolder):
    def __init__(
        self, game, allow_president_sale=False, no_rebundle_president_buy=False
    ):
        super().__init__()
        self.game = game
        self.bank = game.bank
        self.log = game.log
        self.allow_president_sale = allow_president_sale
        self.no_rebundle_president_buy = no_rebundle_president_buy

    def name(self):
        return "Market"

    def player(self):
        return None

    def owner(self):
        return None

    def buy_shares(
        self,
        entity,
        shares,
        exchange=None,
        exchange_price=None,
        swap=None,
        allow_president_change=True,
        silent=None,
        borrow_from=None,
    ):
        bundle = shares if isinstance(shares, ShareBundle) else ShareBundle(shares)

        if (
            self.allow_president_sale
            and not self.no_rebundle_president_buy
            and bundle.presidents_share
            and bundle.owner == self
        ):
            bundle = ShareBundle(bundle.shares, bundle.corporation.share_percent)

        if (
            bundle.owner.player_
            and not self.game.BUY_SHARE_FROM_OTHER_PLAYER
            and (
                not self.game.CORPORATE_BUY_SHARE_ALLOW_BUY_FROM_PRESIDENT
                or not entity.corporation_
            )
        ):
            raise GameError("Cannot buy share from player")

        corporation = bundle.corporation
        ipoed = corporation.ipoed
        floated = corporation.floated_

        if bundle.presidents_share:
            corporation.ipoed = True

        price = bundle.price
        par_price = corporation.par_price.price if corporation.par_price else None

        if ipoed != corporation.ipoed and not silent:
            self.log.append(
                f"{entity.name} {self.game.ipo_verb(corporation)} {corporation.name} at "
                f"{self.game.format_currency(par_price)}"
            )

        share_str = f"a {bundle.percent}% share "
        if entity != corporation:
            share_str += f"of {corporation.name}"

        from_ = ""
        if bundle.owner == corporation.ipo_owner:
            from_ = f"the {self.game.ipo_name(corporation)}"
        elif bundle.owner.corporation_ and bundle.owner == corporation:
            from_ = "the Treasury"
        elif bundle.owner.corporation_ or bundle.owner.player_:
            from_ = bundle.owner.name
        else:
            from_ = "the market"

        if exchange:
            price = exchange_price or 0
            if exchange == "free":
                if not silent:
                    self.log.append(f"{entity.name} receives {share_str}")
            elif isinstance(exchange, Company):
                if not silent:
                    if exchange_price:
                        self.log.append(
                            f"{entity.name} exchanges {exchange.name} and "
                            f"{self.game.format_currency(price)} from {from_} for {share_str}"
                        )
                    else:
                        self.log.append(
                            f"{entity.name} exchanges {exchange.name} from {from_} for {share_str}"
                        )
        else:
            if swap:
                price -= swap.price

            swap_text = f" + swap of a {swap.percent}% share" if swap else ""
            borrowed = price - entity.cash
            borrowed_text = (
                f" by borrowing {self.game.format_currency(borrowed)} from {borrow_from.name}"
                if borrowed > 0
                else ""
            )

            verb = "redeems" if entity == corporation else "buys"
            if not silent:
                self.log.append(
                    f"{entity.name} {verb} {share_str} from {from_} "
                    f"for {self.game.format_currency(price)}{swap_text}{borrowed_text}"
                )

        if price == 0:
            self.transfer_shares(
                bundle, entity, allow_president_change=allow_president_change
            )
        else:
            receiver = None
            if (
                (
                    corporation.capitalization in ("escrow", "incremental")
                    and bundle.owner.corporation_
                )
                or (bundle.owner.corporation_ and bundle.owner != corporation)
                or (bundle.owner.corporation_ or bundle.owner.player_)
            ):
                receiver = bundle.owner
            else:
                receiver = self.bank

            self.transfer_shares(
                bundle,
                entity,
                spender=self.bank if entity == self else entity,
                receiver=receiver,
                price=price,
                swap=swap,
                swap_to_entity=self if swap else None,
                borrow_from=borrow_from,
                allow_president_change=allow_president_change,
            )

        if corporation.floatable and floated != corporation.floated_:
            self.game.float_corporation(corporation)

    def sell_shares(self, bundle, allow_president_change=True, swap=None, silent=None):
        entity = bundle.owner

        verb = (
            "issues"
            if entity.corporation_ and entity == bundle.corporation
            else "sells"
        )

        price = bundle.price
        if swap:
            price -= swap.price
        price -= self.additional_price_adjustments(bundle)
        swap_text = f" and a {swap.percent}% share" if swap else ""
        swap_to_entity = entity if swap else None

        if not silent:
            self.log_sell_shares(entity, verb, bundle, price, swap_text)

        transfer_to = (
            bundle.corporation
            if self.game.sold_shares_destination(bundle.corporation) == "corporation"
            else self
        )

        self.transfer_shares(
            bundle,
            transfer_to,
            spender=self.bank,
            receiver=entity,
            price=price,
            allow_president_change=allow_president_change,
            swap=swap,
            swap_to_entity=swap_to_entity,
        )

    def log_sell_shares(self, entity, verb, bundle, price, swap_text):
        self.log.append(
            f"{entity.name} {verb} {self.num_presentation(bundle)} "
            f"of {bundle.corporation.name} and receives {self.game.format_currency(price)}{swap_text}"
        )

    def additional_price_adjustments(self, bundle):
        return 0

    def fit_in_bank(self, bundle):
        return (
            bundle.percent + self.percent_of(bundle.corporation)
        ) <= self.game.market_share_limit(bundle.corporation)

    def bank_at_limit(self, corporation):
        return self.common_percent_of(corporation) >= self.game.market_share_limit(
            corporation
        )

    def transfer_shares(
        self,
        bundle,
        to_entity,
        spender=None,
        receiver=None,
        price=None,
        allow_president_change=True,
        swap=None,
        borrow_from=None,
        swap_to_entity=None,
        corporate_transfer=None,
    ):
        corporation = bundle.corporation
        owner = bundle.owner
        previous_president = bundle.president
        price = price if price is not None else bundle.price

        corporation.share_holders[owner] -= bundle.percent
        corporation.share_holders[to_entity] += bundle.percent

        if swap:
            corporation.share_holders[swap.owner] -= swap.percent
            corporation.share_holders[swap_to_entity] += swap.percent
            self.move_share(swap, swap_to_entity)

        if corporation.capitalization == "escrow" and receiver == corporation:
            if corporation.percent_of(corporation) > 50 and spender and price > 0:
                if spender and receiver:
                    spender.spend(price, receiver)
            else:
                spender.spend(price, self.bank)
                corporation.escrow += price
        elif spender and receiver and price > 0:
            spender.spend(price, receiver, borrow_from=borrow_from)

        for share in bundle.shares:
            self.move_share(share, to_entity)

        if not allow_president_change:
            return

        max_shares = self.presidency_check_shares(corporation).values()
        max_shares = max(max_shares) if max_shares else 0

        if (
            self.allow_president_sale
            and max_shares < corporation.presidents_percent
            and bundle.presidents_share
            and to_entity == self
        ):
            corporation.owner = self
            self.log.append(
                f"President's share sold to pool. {corporation.name} enters receivership"
            )
            if bundle.partial:
                self.handle_partial(bundle, self, owner)
            return

        if self.allow_president_sale and owner == self and bundle.presidents_share:
            corporation.owner = to_entity
            self.log.append(
                f"{to_entity.name} becomes the president of {corporation.name}"
            )
            self.log.append(f"{corporation.name} exits receivership")
            self.handle_partial(bundle, to_entity, self)
            return

        if self.allow_president_sale and max_shares < corporation.presidents_percent:
            return

        majority_share_holders = {
            player: p
            for player, p in self.presidency_check_shares(corporation).items()
            if p == max_shares
        }
        if previous_president not in majority_share_holders:
            return

        president = None
        for p in majority_share_holders:
            if p.percent_of(corporation) >= corporation.presidents_percent:
                if previous_president == self:
                    distance_value = 0
                else:
                    if hasattr(self.game, "player_distance_for_president"):
                        distance_value = self.game.player_distance_for_president(
                            previous_president, p
                        )
                    else:
                        distance_value = self.distance(previous_president, p)
                if president is None or distance_value < president_distance:
                    president = p
                    president_distance = distance_value

        if president:
            corporation.owner = president
            self.log.append(
                f"{president.name} becomes the president of {corporation.name}"
            )

            if (
                owner == corporation
                and not bundle.presidents_share
                and self.game.can_swap_for_presidents_share_directly_from_corporation
            ):
                previous_president = (
                    previous_president if previous_president else corporation
                )
            if owner != president and previous_president:
                presidents_share = bundle.presidents_share or next(
                    share for share in owner.shares_of(corporation) if share.president
                )

                if presidents_share:
                    if owner.player and to_entity.player:
                        transfer_to = to_entity
                        swap_to = to_entity
                    else:
                        transfer_to = (
                            corporation
                            if self.game.sold_shares_destination(corporation)
                            == "corporation"
                            else self
                        )
                        swap_to = (
                            previous_president
                            if previous_president.percent_of(corporation)
                            >= presidents_share.percent
                            else transfer_to
                        )

                    self.change_president(
                        presidents_share, swap_to, president, previous_president
                    )

                    if bundle.partial:
                        self.handle_partial(bundle, transfer_to, owner)

    def handle_partial(self, bundle, from_entity, to_entity):
        corp = bundle.corporation
        difference = bundle.shares.sum(lambda x: x.percent) - bundle.percent
        num_shares = difference / corp.share_percent
        for _ in range(int(num_shares)):
            self.move_share(from_entity.shares_of(corp)[0], to_entity)

    def change_president(
        self, presidents_share, swap_to, president, _previous_president=None
    ):
        corporation = presidents_share.corporation
        num_shares = presidents_share.percent / corporation.share_percent

        for s in self.game.shares_for_presidency_swap(
            self.possible_reorder(president.shares_of(corporation)), num_shares
        ):
            self.move_share(s, swap_to)

        self.move_share(presidents_share, president)

    def presidency_check_shares(self, corporation):
        return corporation.player_share_holders

    def possible_reorder(self, shares):
        return shares

    def distance(self, player_a, player_b):
        if not player_a or not player_b:
            return 0

        entities = self.game.possible_presidents
        a = entities.index(player_a)
        b = entities.index(player_b)
        return b - a if a < b else b - (a - len(entities))

    def num_presentation(self, bundle):
        num_shares = bundle.num_shares
        return (
            f"a {bundle.percent}% share" if num_shares == 1 else f"{num_shares} shares"
        )

    def move_share(self, share, to_entity):
        corporation = share.corporation
        share.owner.shares_by_corporation[corporation].remove(share)
        to_entity.shares_by_corporation[corporation].append(share)
        share.owner = to_entity

# %% ../../../nbs/game/engine/00_core.ipynb 39
class Spender:
    def __init__(self):
        self.cash = 0

    def check_cash(self, amount, borrow_from=None):
        available = self.cash + (borrow_from.cash if borrow_from else 0)
        if (available - amount) < 0:
            raise GameError(f"{self.name} has {self.cash} and cannot spend {amount}")

    def check_positive(self, amount):
        if amount <= 0:
            raise GameError(f"{amount} is not valid to spend")

    def spend(
        self, cash, receiver, check_cash=True, check_positive=True, borrow_from=None
    ):
        if check_cash:
            self.check_cash(cash, borrow_from=borrow_from)
        if check_positive:
            self.check_positive(cash)

        # Check if we need to borrow from our borrow_from target
        if borrow_from and (cash > self.cash):
            amount_borrowed = cash - self.cash
            self.cash = 0
            borrow_from.cash -= amount_borrowed
        else:
            self.cash -= cash

        receiver.cash += cash

# %% ../../../nbs/game/engine/00_core.ipynb 41
class BaseMovement:
    def __init__(self, market):
        self.market = market

    def share_price(self, coordinates):
        row, column = coordinates
        return (
            self.market.market[row][column]
            if row < len(self.market.market) and column < len(self.market.market[row])
            else None
        )

    def left(self, corporation, coordinates):
        raise NotImplementedError

    def right(self, corporation, coordinates):
        raise NotImplementedError

    def down(self, corporation, coordinates):
        raise NotImplementedError

    def up(self, corporation, coordinates):
        raise NotImplementedError


class TwoDimensionalMovement(BaseMovement):
    def left(self, corporation, coordinates):
        r, c = coordinates
        if c > 0 and self.share_price([r, c - 1]):
            return [r, c - 1]
        else:
            return self.down(corporation, coordinates)

    def right(self, corporation, coordinates):
        r, c = coordinates
        if c + 1 >= len(self.market.market[r]):
            return self.up(corporation, coordinates)
        else:
            return [r, c + 1]

    def down(self, _corporation, coordinates):
        r, c = coordinates
        if r + 1 < len(self.market.market):
            r += 1
        return [r, c]

    def up(self, _corporation, coordinates):
        r, c = coordinates
        if r - 1 >= 0:
            r -= 1
        return [r, c]


class OneDimensionalMovement(BaseMovement):
    def left(self, _corporation, coordinates):
        r, c = coordinates
        if c - 1 >= 0:
            c -= 1
        return [r, c]

    def right(self, _corporation, coordinates):
        r, c = coordinates
        if c + 1 < len(self.market.market[r]):
            c += 1
        return [r, c]

    def down(self, corporation, coordinates):
        return self.left(corporation, coordinates)

    def up(self, corporation, coordinates):
        return self.right(corporation, coordinates)


class ZigZagMovement(BaseMovement):
    def __init__(self, market, ledge_movement):
        self.ledge_movement = ledge_movement
        super().__init__(market)

    def left(self, _corporation, coordinates):
        r, c = coordinates
        if self.ledge_movement:
            c -= 2
            c = 0 if c < 0 else c
        elif c - 2 >= 0:
            c -= 2
        return [r, c]

    def right(self, _corporation, coordinates):
        r, c = coordinates
        if self.ledge_movement:
            c += 2
            c = len(self.market.market[r]) - 1 if c >= len(self.market.market[r]) else c
        elif c + 2 < len(self.market.market[r]):
            c += 2
        return [r, c]

    def down(self, _corporation, coordinates):
        r, c = coordinates
        if c > 0:
            c -= 1
        return [r, c]

    def up(self, _corporation, coordinates):
        r, c = coordinates
        if c + 1 < len(self.market.market[r]):
            c += 1
        return [r, c]

# %% ../../../nbs/game/engine/00_core.ipynb 43
class StockMarket:
    def __init__(
        self,
        market,
        unlimited_types,
        multiple_buy_types=None,
        zigzag=None,
        ledge_movement=None,
    ):
        self.par_prices = []
        self.has_close_cell = False
        self.zigzag = zigzag
        self.market = [
            [
                self.create_share_price(
                    code, r_index, c_index, unlimited_types, multiple_buy_types
                )
                for c_index, code in enumerate(row)
            ]
            for r_index, row in enumerate(market)
        ]

        for row in self.market:
            for price in row:
                if price and price.can_par:
                    self.par_prices.append(price)
                if price and price.type == "close":
                    self.has_close_cell = True

        self.par_prices.sort(
            key=lambda p: (p.price, p.coordinates[1], p.coordinates[0]), reverse=True
        )

        if self.zigzag:
            self.movement = ZigZagMovement(self, ledge_movement)
        elif self.one_d():
            self.movement = OneDimensionalMovement(self)
        else:
            self.movement = TwoDimensionalMovement(self)

    def one_d(self):
        return all(len(row) == 1 for row in self.market)

    def set_par(self, corporation, share_price):
        share_price.corporations.append(corporation)
        corporation.share_price = share_price
        corporation.par_price = share_price
        corporation.original_par_price = share_price

    def right_ledge(self, coordinates):
        row, col = coordinates
        return col + 1 == len(self.market[row])

    def move_right(self, corporation):
        coordinates = self.right(corporation, corporation.share_price.coordinates)
        self.move(corporation, coordinates)

    def right(self, corporation, coordinates):
        return self.movement.right(corporation, coordinates)

    def move_up(self, corporation):
        coordinates = self.up(corporation, corporation.share_price.coordinates)
        self.move(corporation, coordinates)

    def up(self, corporation, coordinates):
        return self.movement.up(corporation, coordinates)

    def move_down(self, corporation):
        coordinates = self.down(corporation, corporation.share_price.coordinates)
        self.move(corporation, coordinates)

    def down(self, corporation, coordinates):
        return self.movement.down(corporation, coordinates)

    def move_left(self, corporation):
        coordinates = self.left(corporation, corporation.share_price.coordinates)
        self.move(corporation, coordinates)

    def left(self, corporation, coordinates):
        return self.movement.left(corporation, coordinates)

    def find_share_price(self, corporation, directions):
        return self.find_relative_share_price(
            corporation.share_price, corporation, directions
        )

    def find_relative_share_price(self, share, corporation, directions):
        coordinates = share.coordinates
        price = self.share_price(coordinates)

        for direction in directions:
            if direction == "left":
                coordinates = self.left(corporation, coordinates)
            elif direction == "right":
                coordinates = self.right(corporation, coordinates)
            elif direction == "down":
                coordinates = self.down(corporation, coordinates)
            elif direction == "up":
                coordinates = self.up(corporation, coordinates)

            price = self.share_price(coordinates) or price

        return price

    def max_reached(self):
        return self.max_reached

    def move(self, corporation, coordinates, force=False):
        share_price = self.share_price(coordinates)

        if not share_price or share_price == corporation.share_price:
            return

        if not force and not share_price.normal_movement():
            return

        corporation.share_price.corporations.remove(corporation)
        corporation.share_price = share_price
        self.max_reached = True if share_price.end_game_trigger() else False
        share_price.corporations.append(corporation)

    def share_prices_with_types(self, types):
        return sorted(
            [
                price
                for row in self.market
                for price in row
                if price and any(t in types for t in price.types)
            ],
            key=lambda p: p.price,
            reverse=True,
        )

    def share_price(self, coordinates):
        row, column = coordinates

        if row < len(self.market) and column < len(self.market[row]):
            return self.market[row][column]

    def remove_par(self, price):
        self.par_prices.remove(price)
        price.remove_par()

# %% ../../../nbs/game/engine/00_core.ipynb 45
class Token:
    def __init__(
        self, corporation, price=0, logo=None, simple_logo=None, type="normal"
    ):
        self.corporation = corporation
        self.price = price
        self.logo = logo or corporation.logo
        self.simple_logo = simple_logo or (
            corporation.simple_logo if corporation else self.logo
        )
        self.used = False
        self.extra = None  # Is this in an extra slot? (bull token)
        self.cheater = None
        self.type = type
        self.city = None
        self.hex = None
        self.status = None
        self.location_type = None

    def destroy(self):
        if self.corporation:
            self.corporation.tokens.remove(self)
        self.remove()

    def remove(self):
        if self.location_type == "city":
            if self.city:
                self.city.tokens = [t for t in self.city.tokens if t != self]
                if self.city.extra_tokens and self in self.city.extra_tokens:
                    self.city.extra_tokens.remove(self)
        elif self.location_type == "hex":
            if self.hex:
                self.hex.remove_token(self)

        self.city = None
        self.hex = None
        self.used = False
        self.extra = False
        self.cheater = False
        self.location_type = None

    def swap(self, other_token, check_tokenable=True, free=True):
        city = self.city
        hex = self.hex
        extra = self.extra
        location_type = self.location_type
        self.remove()
        corporation = other_token.corporation

        if (
            not extra
            and check_tokenable
            and location_type == "city"
            and not city.tokenable(corporation, free=free, tokens=[other_token])
        ):
            return

        if location_type == "city":
            city.place_token(
                corporation,
                other_token,
                free=free,
                check_tokenable=check_tokenable,
                extra_slot=extra,
            )
        elif location_type == "hex":
            hex.place_token(other_token)

    def move(self, new_location):
        self.remove()

        if isinstance(new_location, Engine.Part.City):
            new_location.place_token(self.corporation, self, free=True)
        elif isinstance(new_location, Engine.Part.Hex):
            new_location.place_token(self)

    def place(self, location, extra=None, cheater=None):
        self.used = True

        if isinstance(location, Engine.Part.City):
            self.location_type = "city"
            self.city = location
            self.hex = location.hex
        elif isinstance(location, Engine.Hex):
            self.location_type = "hex"
            self.hex = location

        self.extra = extra
        self.cheater = cheater

# %% ../../../nbs/game/engine/00_core.ipynb 47
from typing import Union, List


class Train(Ownable):
    def __init__(
        self,
        name: str,
        distance: Union[int, List[dict]],
        price: int,
        index: int = 0,
        **opts,
    ):
        super().__init__()
        self.sym = name
        self.name = name
        self.distance = distance
        self.price = price
        self.index = index
        self.rusts_on = opts.get("rusts_on", None)
        self.obsolete_on = opts.get("obsolete_on", None)
        self.available_on = opts.get("available_on", None)
        self.discount = opts.get("discount", None)
        self.salvage = opts.get("salvage", None)
        self.multiplier = opts.get("multiplier", None)
        self.no_local = opts.get("no_local", None)
        self.buyable = True
        self.rusted = False
        self.obsolete = False
        self.operated = False
        self.ever_operated = False
        self.track_type = opts.get("track_type", "broad")
        self.events = [
            e
            for e in (opts.get("events", []) or [])
            if self.index == (e.get("when", 1) - 1)
        ]
        self.reserved = opts.get("reserved", False)
        self.requires_token = opts.get("requires_token", True)
        self.init_variants(opts.get("variants", []))

    def set_operated(self, value):
        self.ever_operated = value
        self.operated = value

    def init_variants(self, variants):
        variants = variants or []
        self.variant = {
            "name": self.name,
            "distance": self.distance,
            "multiplier": self.multiplier,
            "price": self.price,
            "rusts_on": self.rusts_on,
            "obsolete_on": self.obsolete_on,
            "discount": self.discount,
            "salvage": self.salvage,
            "track_type": self.track_type,
        }
        variants.insert(0, self.variant)
        self.variants = {v["name"]: v for v in variants}

    def set_variant(self, new_variant):
        if not new_variant:
            return

        self.variant = self.variants[new_variant]

        for key, value in self.variant.items():
            setattr(self, key, value)

        if hasattr(self, "local"):
            delattr(self, "local")

    def remove_variants(self):
        self.variants = {
            name: variant
            for name, variant in self.variants.items()
            if name == self.name
        }

    def names_to_prices(self):
        return {name: variant["price"] for name, variant in self.variants.items()}

    def get_price(self, exchange_train=None, variant=None):
        discount = variant["discount"] if variant else self.discount
        price = variant["price"] if variant else self.price
        return price - (
            discount.get(exchange_train.name, 0) if discount and exchange_train else 0
        )

    def get_id(self):
        return f"{self.sym}-{self.index}"

    def get_min_price(self, ability=None):
        if not self.from_depot():
            return 1

        if not ability:
            return self.price

        return min(
            [
                a.discounted_price(self, self.price)
                for a in (ability if isinstance(ability, list) else [ability])
            ]
        )

    def from_depot(self):
        return isinstance(self.owner, Depot)

    def is_buyable(self, allow_obsolete_buys=False):
        return self.buyable and (not self.obsolete or allow_obsolete_buys)

    def is_local(self):
        if self.no_local:
            return False
        if hasattr(self, "local"):
            return self.local

        self.local = (
            self.distance == 1
            if isinstance(self.distance, int)
            else any(
                n["visit"] == 1
                for n in self.distance
                if n.get("nodes", []).count("city") > 0
            )
        )
        return self.local

    def __str__(self):
        return f"<Train: {self.get_id()}>"

# %% ../../../nbs/game/engine/00_core.ipynb 50
from collections import defaultdict


class Phase:
    def __init__(self, phases, game):
        self.index = 0
        self.phases = phases
        self.game = game
        self.depot = game.depot
        self.log = game.log
        self.setup_phase()

    def buying_train(self, entity, train, source):
        while train.sym in self.next_on:
            self.next_phase()

        self.game.rust_trains(train, entity)
        self.depot.depot_trains(clear=True)

        for event in train.events:
            getattr(self.game, f"event_{event['type']}")()
        train.events.clear()
        self.game.after_buying_train(train, source)

    @property
    def previous(self):
        return self.phases[: self.index]

    @property
    def current(self):
        return self.phases[self.index]

    @property
    def upcoming(self):
        return (
            self.phases[self.index + 1] if self.index + 1 < len(self.phases) else None
        )

    def train_limit(self, entity):
        if isinstance(self.train_limit, dict):
            return self.train_limit.get(entity.type, 0)
        else:
            return self.train_limit

    def available(self, phase_name):
        if not phase_name:
            return False
        index = next(
            (i for i, phase in enumerate(self.phases) if phase["name"] == phase_name),
            -1,
        )
        return index <= self.index

    def setup_phase(self):
        phase = self.phases[self.index]

        self.name = phase["name"]
        self.operating_rounds = phase.get("operating_rounds")
        self.train_limit = phase.get("train_limit")
        self.tiles = list(phase.get("tiles", []))
        self.events = phase.get("events", [])
        self.status = phase.get("status", [])
        self.corporation_sizes = phase.get("corporation_sizes")
        self.next_on = (
            list(self.phases[self.index + 1]["on"])
            if self.index + 1 < len(self.phases)
            else []
        )

        log_msg = f"-- Phase {self.name} ("
        if self.operating_rounds:
            log_msg += f"Operating Rounds: {self.operating_rounds} | "
        log_msg += f"Train Limit: {self.train_limit_to_str(self.train_limit)}"
        log_msg += f" | Available Tiles: {', '.join(map(str.capitalize, self.tiles))})"
        self.log.append(log_msg)
        self.trigger_events()

    def trigger_events(self):
        for company in self.game.companies:
            if company.owner:
                for ability in self.game.abilities(
                    company, "revenue_change", on_phase=self.name
                ):
                    company.revenue = ability.revenue

                for _ in self.game.abilities(company, "close", on_phase=self.name):
                    self.log.append(f"Company {company.name} closes")
                    company.close()

        for entity in self.game.companies + self.game.corporations:
            entity.remove_ability_when(self.name)

    def next_phase(self):
        self.index += 1
        self.setup_phase()

    def train_limit_to_str(self, train_limit):
        if isinstance(train_limit, dict):
            return ", ".join(f"{type}: {limit}" for type, limit in train_limit.items())
        else:
            return str(train_limit)
