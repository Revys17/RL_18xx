# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/game/engine/03_actions.ipynb.

# %% auto 0
__all__ = ['BaseAction', 'AcquireCompany', 'Assign', 'Bankrupt', 'Bid', 'BlindBid', 'BorrowTrain', 'BuyCompany', 'BuyCorporation',
           'BuyPower', 'BuyShares', 'SellShares', 'BuyToken', 'BuyTrain', 'Choose', 'ChooseAbility', 'ClaimHexToken',
           'CombinedTrains', 'Convert', 'CorporateBuyShares', 'CreditMobilier', 'DestinationConnection', 'DiscardTrain',
           'Dividend', 'DoubleHeadTrains', 'EndGame', 'FailedMerge', 'HexToken', 'LayTile', 'Message', 'Log',
           'ManualCloseCompany', 'Merge', 'MoveBid', 'Offer', 'Par', 'Pass', 'PayoffDebt', 'TakeLoan',
           'PayoffPlayerDebt', 'PlaceToken', 'ProgramEnable', 'ProgramDisable', 'ProgramAuctionBid', 'ProgramBuyShares',
           'ProgramClosePass', 'ProgramHarzbahnDraftPass', 'ProgramIndependentMines', 'ProgramMergerPass',
           'ProgramSharePass', 'PurchaseTrain', 'ReassignTrains', 'Redo', 'RemoveHexToken', 'RemoveToken', 'Respond',
           'RunRoutes', 'ScrapTrain', 'SellCompany', 'Short', 'SpecialBuy', 'Split', 'SwapTrain', 'SwitchTrains',
           'Undo', 'UseGraph', 'ViewMergeOptions']

# %% ../../../nbs/game/engine/03_actions.ipynb 3
from .core import ShareBundle, Item
from .graph import Route

# %% ../../../nbs/game/engine/03_actions.ipynb 5
from abc import ABC, abstractmethod
import time


class BaseAction(ABC):
    def __init__(self, entity):
        self.entity = entity
        self.created_at = time.time()
        self.auto_actions = []

    @staticmethod
    def from_h(h, game):
        entity_type = h.get("entity_type")
        entity_id = h.get("entity")
        entity = game.get(entity_type, entity_id) or Player(None, entity_id)
        obj = new(entity, **Base.h_to_args(h, game))
        if entity.player and h.get("user") != entity.player.id:
            obj.user = h.get("user")
        obj.created_at = h.get("created_at") or time.time()
        obj.auto_actions = [
            Base.action_from_h(auto_h, game) for auto_h in h.get("auto_actions", [])
        ]
        return obj

    @staticmethod
    def action_from_h(h, game):
        action_type = Base.type(h.get("type"))
        action_class = getattr(Engine.Action, action_type)
        return action_class.from_h(h, game)

    @staticmethod
    def h_to_args(h, game):
        return {}

    @property
    def args_to_h(self):
        return {}

    def clear_cache(self):
        self._h = None

    def to_h(self):
        if not hasattr(self, "_h") or self._h is None:
            self._h = {
                "type": self.type,
                "entity": self.entity.id,
                "entity_type": self.type_s(self.entity),
                "id": self.id,
                "user": self.user if hasattr(self, "user") else None,
                "created_at": int(self.created_at),
                "auto_actions": [auto_action.to_h for auto_action in self.auto_actions]
                if self.auto_actions
                else None,
                **self.args_to_h,
            }
            self._h = {k: v for k, v in self._h.items() if v is not None}
        return self._h

    @abstractmethod
    def pass_(self):
        return False

    def copy(self, game):
        return self.from_h(self.to_h(), game)

    @property
    def free(self):
        return False

    def __lt__(self, other):
        if self.id and other.id:
            return self.id < other.id
        else:
            return int(self.created_at) < int(other.created_at)

# %% ../../../nbs/game/engine/03_actions.ipynb 8
class AcquireCompany(BaseAction):
    def __init__(self, entity, company):
        super().__init__(entity)
        self.company = company

    @classmethod
    def from_h(cls, h, game):
        return cls(
            entity=game.get(h["entity_type"], h["entity"]),
            company=game.company_by_id(h["company"]),
        )

    def to_h(self):
        return {
            "type": "acquire_company",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "company": self.company.id,
        }

    def args_to_h(self):
        return {
            "company": self.company.id,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 10
class Assign(BaseAction):
    def __init__(self, entity, target):
        super().__init__(entity)
        self.target = target

    @classmethod
    def from_h(cls, h, game):
        return cls(
            entity=game.get(h["entity_type"], h["entity"]),
            target=game.get(h["target_type"], h["target"]),
        )

    def to_h(self):
        return {
            "type": "assign",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "target": self.target.id,
            "target_type": type_s(self.target),
        }

    def args_to_h(self):
        return {
            "target": self.target.id,
            "target_type": type_s(self.target),
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 12
class Bankrupt(BaseAction):
    def __init__(self, entity, option=None):
        super().__init__(entity)
        self.option = option

    @classmethod
    def from_h(cls, h, _game):
        return cls(entity=h["entity"], option=h["option"])

    def to_h(self):
        return {
            "type": "bankrupt",
            "entity": self.entity.id,
            "option": self.option,
        }

    def args_to_h(self):
        return {
            "option": self.option,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 14
class Bid(BaseAction):
    def __init__(self, entity, price, company=None, corporation=None, minor=None):
        super().__init__(entity)
        self.company = company
        self.corporation = corporation
        self.minor = minor
        self.price = price

    @classmethod
    def from_h(cls, h, game):
        return cls(
            entity=h["entity"],
            company=game.company_by_id(h["company"]),
            corporation=game.corporation_by_id(h["corporation"]),
            minor=game.minor_by_id(h["minor"]),
            price=h["price"],
        )

    def to_h(self):
        return {
            "type": "bid",
            "entity": self.entity.id,
            "company": self.company.id if self.company else None,
            "corporation": self.corporation.id if self.corporation else None,
            "minor": self.minor.id if self.minor else None,
            "price": self.price,
        }

    def args_to_h(self):
        return {
            "company": self.company.id if self.company else None,
            "corporation": self.corporation.id if self.corporation else None,
            "minor": self.minor.id if self.minor else None,
            "price": self.price,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 16
class BlindBid(BaseAction):
    def __init__(self, entity, bids=None):
        super().__init__(entity)
        self.bids = bids or []

    @classmethod
    def from_h(cls, h, _game):
        return cls(
            entity=h["entity"],
            bids=[int(bid) for bid in h["bids"]] if "bids" in h else [],
        )

    def to_h(self):
        return {
            "type": "blind_bid",
            "entity": self.entity.id,
            "bids": [str(bid) for bid in self.bids],
        }

    def args_to_h(self):
        return {"bids": [str(bid) for bid in self.bids]}

# %% ../../../nbs/game/engine/03_actions.ipynb 18
class BorrowTrain(BaseAction):
    def __init__(self, entity, train):
        super().__init__(entity)
        self.train = train

    @classmethod
    def from_h(cls, h, game):
        return cls(entity=h["entity"], train=game.train_by_id(h["train"]))

    def to_h(self):
        return {
            "type": "borrow_train",
            "entity": self.entity.id,
            "train": self.train.id,
        }

    def args_to_h(self):
        return {"train": self.train.id}

# %% ../../../nbs/game/engine/03_actions.ipynb 20
class BuyCompany(BaseAction):
    def __init__(self, entity, company, price):
        super().__init__(entity)
        self.company = company
        self.price = price

    @classmethod
    def from_h(cls, h, game):
        return cls(
            entity=h["entity"],
            company=game.company_by_id(h["company"]),
            price=h["price"],
        )

    def to_h(self):
        return {
            "type": "buy_company",
            "entity": self.entity.id,
            "company": self.company.id,
            "price": self.price,
        }

    def args_to_h(self):
        return {"company": self.company.id, "price": self.price}

# %% ../../../nbs/game/engine/03_actions.ipynb 22
class BuyCorporation(BaseAction):
    def __init__(self, entity, price, corporation=None, minor=None):
        super().__init__(entity)
        self.corporation = corporation
        self.minor = minor
        self.price = price

    @classmethod
    def from_h(cls, h, game):
        return cls(
            entity=h["entity"],
            corporation=game.corporation_by_id(h["corporation"]),
            minor=game.minor_by_id(h["minor"]),
            price=h["price"],
        )

    def to_h(self):
        return {
            "type": "buy_corporation",
            "entity": self.entity.id,
            "corporation": self.corporation.id if self.corporation else None,
            "minor": self.minor.id if self.minor else None,
            "price": self.price,
        }

    def args_to_h(self):
        return {
            "corporation": self.corporation.id if self.corporation else None,
            "minor": self.minor.id if self.minor else None,
            "price": self.price,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 24
class BuyPower(BaseAction):
    def __init__(self, entity, power):
        super().__init__(entity)
        self.power = power

    @classmethod
    def from_h(cls, h, game):
        return cls(entity=h["entity"], power=h["power"])

    def to_h(self):
        return {"type": "buy_power", "entity": self.entity.id, "power": self.power}

    def args_to_h(self):
        return {"power": self.power}

# %% ../../../nbs/game/engine/03_actions.ipynb 26
class BuyShares(BaseAction):
    def __init__(
        self,
        entity,
        shares,
        share_price=None,
        percent=None,
        swap=None,
        purchase_for=None,
        borrow_from=None,
        total_price=None,
    ):
        super().__init__(entity)
        self.bundle = ShareBundle(
            shares if isinstance(shares, list) else [shares], percent
        )
        self.bundle.share_price = share_price
        self.swap = swap
        self.purchase_for = purchase_for
        self.borrow_from = borrow_from
        self.total_price = total_price

    @classmethod
    def from_h(cls, h, game):
        shares = [game.share_by_id(id) for id in h["shares"]]
        share_price = h["share_price"]
        percent = h["percent"]
        swap = game.share_by_id(h["swap"]) if "swap" in h else None
        purchase_for_type = h["purchase_for_type"]
        purchase_for = (
            game.get(purchase_for_type, h["purchase_for"])
            if purchase_for_type
            else None
        )
        borrow_from_type = h["borrow_from_type"]
        borrow_from = (
            game.get(borrow_from_type, h["borrow_from"]) if borrow_from_type else None
        )
        total_price = h["total_price"]

        return cls(
            entity=h["entity"],
            shares=shares,
            share_price=share_price,
            percent=percent,
            swap=swap,
            purchase_for=purchase_for,
            borrow_from=borrow_from,
            total_price=total_price,
        )

    def to_h(self):
        return {
            "type": "buy_shares",
            "entity": self.entity.id,
            "shares": [share.id for share in self.bundle.shares],
            "share_price": self.bundle.share_price,
            "percent": self.bundle.percent,
            "swap": self.swap.id if self.swap else None,
            "purchase_for_type": type_s(self.purchase_for)
            if self.purchase_for
            else None,
            "purchase_for": self.purchase_for.id if self.purchase_for else None,
            "borrow_from_type": type_s(self.borrow_from) if self.borrow_from else None,
            "borrow_from": self.borrow_from.id if self.borrow_from else None,
            "total_price": self.total_price,
        }

    def args_to_h(self):
        return {
            "shares": [share.id for share in self.bundle.shares],
            "percent": self.bundle.percent,
            "share_price": self.bundle.share_price,
            "swap": self.swap.id if self.swap else None,
            "purchase_for_type": type_s(self.purchase_for)
            if self.purchase_for
            else None,
            "purchase_for": self.purchase_for.id if self.purchase_for else None,
            "borrow_from_type": type_s(self.borrow_from) if self.borrow_from else None,
            "borrow_from": self.borrow_from.id if self.borrow_from else None,
            "total_price": self.total_price,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 28
class SellShares(BaseAction):
    def __init__(self, entity, shares, share_price=None, percent=None, swap=None):
        super().__init__(entity)
        self.bundle = ShareBundle(shares, percent)
        self.bundle.share_price = share_price
        self.swap = swap

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get(data["entity_type"], data["entity"]),
            shares=[game.share_by_id(id) for id in data["shares"]],
            share_price=data["share_price"],
            percent=data["percent"],
            swap=game.share_by_id(data["swap"]) if "swap" in data else None,
        )

    def to_dict(self):
        return {
            "type": "sell_shares",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "shares": [share.id for share in self.bundle.shares],
            "share_price": self.bundle.share_price,
            "percent": self.bundle.percent,
            "swap": self.swap.id if self.swap else None,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 30
class BuyToken(BaseAction):
    def __init__(self, entity, city, slot, price):
        super().__init__(entity)
        self.city = city
        self.slot = slot
        self.price = price

    @classmethod
    def from_h(cls, h, game):
        city = game.city_by_id(h["city"])
        slot = h["slot"]
        price = h["price"]

        return cls(entity=h["entity"], city=city, slot=slot, price=price)

    def to_h(self):
        return {
            "type": "buy_token",
            "entity": self.entity.id,
            "city": self.city.id,
            "slot": self.slot,
            "price": self.price,
        }

    def args_to_h(self):
        return {"city": self.city.id, "slot": self.slot, "price": self.price}

# %% ../../../nbs/game/engine/03_actions.ipynb 32
class BuyTrain(BaseAction):
    def __init__(
        self,
        entity,
        train,
        price,
        variant=None,
        exchange=None,
        shell=None,
        slots=None,
        extra_due=None,
        warranties=None,
    ):
        super().__init__(entity)
        self.train = train
        self.price = price
        self.variant = variant
        self.exchange = exchange
        self.shell = shell
        self.slots = slots if slots is not None else []
        self.extra_due = extra_due
        self.warranties = warranties

    @classmethod
    def from_h(cls, h, game):
        train = game.train_by_id(h["train"])
        price = h["price"]
        variant = h["variant"]
        exchange = game.train_by_id(h["exchange"])
        shell_name = h["shell"]
        shell = cls.shell_by_name(shell_name, game)
        slots = [int(slot) for slot in h["slots"]] if "slots" in h else None
        extra_due = h["extra_due"]
        warranties = h["warranties"]

        return cls(
            entity=h["entity"],
            train=train,
            price=price,
            variant=variant,
            exchange=exchange,
            shell=shell,
            slots=slots,
            extra_due=extra_due,
            warranties=warranties,
        )

    def to_h(self):
        return {
            "type": "buy_train",
            "entity": self.entity.id,
            "train": self.train.id,
            "price": self.price,
            "variant": self.variant,
            "exchange": self.exchange.id if self.exchange else None,
            "shell": self.shell.name if self.shell else None,
            "slots": self.slots,
            "extra_due": bool(self.extra_due) if self.extra_due else None,
            "warranties": self.warranties,
        }

    def args_to_h(self):
        return {
            "train": self.train.id,
            "price": self.price,
            "variant": self.variant,
            "exchange": self.exchange.id if self.exchange else None,
            "shell": self.shell.name if self.shell else None,
            "slots": self.slots,
            "extra_due": bool(self.extra_due) if self.extra_due else None,
            "warranties": self.warranties,
        }

    @staticmethod
    def shell_by_name(name, game):
        if not name:
            return None

        for system in [corp for corp in game.corporations if corp.system]:
            for shell in system.shells:
                if shell.name == name:
                    return shell

        return None

# %% ../../../nbs/game/engine/03_actions.ipynb 34
class Choose(BaseAction):
    def __init__(self, entity, choice):
        super().__init__(entity)
        self.choice = choice

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get(data["entity_type"], data["entity"]), choice=data["choice"]
        )

    def to_dict(self):
        return {
            "type": "choose",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "choice": self.choice,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 36
class ChooseAbility(Choose):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 38
class ClaimHexToken(BaseAction):
    def __init__(self, entity, hex, token_type=None):
        super().__init__(entity)
        self.hex = hex
        self.token_type = token_type

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get(data["entity_type"], data["entity"]),
            hex=game.hex_by_id(data["hex"]),
            token_type=data["token_type"],
        )

    def to_dict(self):
        return {
            "type": "claim_hex_token",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "hex": self.hex.id,
            "token_type": self.token_type,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 40
class CombinedTrains(BaseAction):
    def __init__(self, entity, base, additional_train, additional_train_variant):
        super().__init__(entity)
        self.base = base
        self.additional_train = additional_train
        self.additional_train_variant = additional_train_variant

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get(data["entity_type"], data["entity"]),
            base=game.train_by_id(data["base"]),
            additional_train=game.train_by_id(data["additional_train"]),
            additional_train_variant=data["additional_train_variant"],
        )

    def to_dict(self):
        return {
            "type": "combined_trains",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "base": self.base.id if self.base else None,
            "additional_train": self.additional_train.id
            if self.additional_train
            else None,
            "additional_train_variant": self.additional_train_variant,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 42
class Convert(BaseAction):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 44
class CorporateBuyShares(BuyShares):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 46
class CorporateBuyShares(SellShares):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 48
class CreditMobilier(BaseAction):
    def __init__(self, entity, hex, amount):
        super().__init__(entity)
        self.hex = hex
        self.amount = amount

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get(data["entity_type"], data["entity"]),
            hex=game.hex_by_id(data["hex"]),
            amount=data["amount"],
        )

    def to_dict(self):
        return {
            "type": "credit_mobilier",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "hex": self.hex.id,
            "amount": self.amount,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 50
class DestinationConnection(BaseAction):
    def __init__(self, entity, corporations=None, minors=None, hexes=None):
        super().__init__(entity)
        self.corporations = corporations if corporations else []
        self.minors = minors if minors else []
        self.hexes = hexes if hexes else []

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get(data["entity_type"], data["entity"]),
            corporations=[
                game.corporation_by_id(c) for c in data.get("corporations", [])
            ],
            minors=[game.minor_by_id(m) for m in data.get("minors", [])],
            hexes=[game.hex_by_id(h) for h in data.get("hexes", [])],
        )

    def to_dict(self):
        return {
            "type": "destination_connection",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "corporations": [c.id for c in self.corporations],
            "minors": [m.id for m in self.minors],
            "hexes": [h.id for h in self.hexes],
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 52
class DiscardTrain(BaseAction):
    def __init__(self, entity, train):
        super().__init__(entity)
        self.train = train

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get(data["entity_type"], data["entity"]),
            train=game.train_by_id(data["train"]),
        )

    def to_dict(self):
        return {
            "type": "discard_train",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "train": self.train.id,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 54
class Dividend(BaseAction):
    def __init__(self, entity, kind, amount=None):
        super().__init__(entity)
        self.kind = kind
        self.amount = amount

    @classmethod
    def from_dict(cls, data, _game):
        return cls(
            entity=game.get(data["entity_type"], data["entity"]),
            kind=data["kind"],
            amount=data.get("amount"),
        )

    def to_dict(self):
        return {
            "type": "dividend",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "kind": self.kind,
            "amount": self.amount,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 56
class DoubleHeadTrains(BaseAction):
    def __init__(self, entity, trains):
        super().__init__(entity)
        self.trains = trains

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get(data["entity_type"], data["entity"]),
            trains=[game.train_by_id(train_id) for train_id in data["trains"]],
        )

    def to_dict(self):
        return {
            "type": "double_head_trains",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "trains": [train.id for train in self.trains],
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 58
class EndGame(BaseAction):
    def free(self):
        return True

    @classmethod
    def from_dict(cls, data, game):
        return cls(entity=game.get(data["entity_type"], data["entity"]))

    def to_dict(self):
        return {
            "type": "end_game",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 60
class FailedMerge(BaseAction):
    def __init__(self, entity, corporations):
        super().__init__(entity)
        self.corporations = corporations

    @classmethod
    def from_dict(cls, data, game):
        corporations = [game.corporation_by_id(c_id) for c_id in data["corporations"]]
        return cls(
            entity=game.get(data["entity_type"], data["entity"]),
            corporations=corporations,
        )

    def to_dict(self):
        return {
            "type": "failed_merge",
            "entity": self.entity.id,
            "entity_type": type_s(self.entity),
            "corporations": [c.id for c in self.corporations],
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 62
class HexToken(BaseAction):
    def __init__(self, entity, hex, cost=None, token_type=None, token=None):
        super().__init__(entity)
        self.hex = hex
        self.cost = cost
        self.token = token or entity.find_token_by_type(token_type) if entity else None

    @classmethod
    def from_dict(cls, data, game):
        hex = game.hex_by_id(data["hex"])
        cost = data["cost"]
        token_type = data["token_type"]
        entity = (
            game.get(data["entity_type"], data["entity"]) if data["entity"] else None
        )
        return cls(entity=entity, hex=hex, cost=cost, token_type=token_type)

    def to_dict(self):
        return {
            "type": "hex_token",
            "entity": self.entity.id if self.entity else None,
            "entity_type": type_s(self.entity) if self.entity else None,
            "hex": self.hex.id,
            "cost": self.cost,
            "token_type": self.token.type
            if self.token and self.token.type != "normal"
            else None,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 64
class LayTile(BaseAction):
    def __init__(self, entity, tile, hex, rotation, combo_entities=None):
        super().__init__(entity)
        self.hex = hex
        self.tile = tile
        self.rotation = rotation
        self.combo_entities = combo_entities or []

    @classmethod
    def from_dict(cls, data, game):
        tile = game.tile_by_id(data["tile"])
        hex = game.hex_by_id(data["hex"])
        rotation = data["rotation"]
        combo_entities = [
            game.company_by_id(id) for id in (data.get("combo_entities") or [])
        ]
        entity = (
            game.get(data["entity_type"], data["entity"]) if data["entity"] else None
        )
        return cls(
            entity=entity,
            tile=tile,
            hex=hex,
            rotation=rotation,
            combo_entities=combo_entities,
        )

    def to_dict(self):
        return {
            "type": "lay_tile",
            "entity": self.entity.id if self.entity else None,
            "entity_type": type_s(self.entity) if self.entity else None,
            "hex": self.hex.id,
            "tile": self.tile.id,
            "rotation": self.rotation,
            "combo_entities": [entity.id for entity in self.combo_entities],
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 66
class Message(BaseAction):
    def __init__(self, entity, message):
        super().__init__(entity)
        self.message = message

    @classmethod
    def from_dict(cls, data, _):
        return cls(entity=None, message=data.get("message"))

    def to_dict(self):
        return {
            "type": "message",
            "message": self.message,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 68
class Log(Message):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 70
class ManualCloseCompany(BaseAction):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 72
class Merge(BaseAction):
    def __init__(self, entity, corporation=None, minor=None):
        super().__init__(entity)
        self.corporation = corporation
        self.minor = minor

    @classmethod
    def from_dict(cls, data, game):
        corporation = game.corporation_by_id(data.get("corporation"))
        minor = game.minor_by_id(data.get("minor"))
        entity = (
            game.get(data["entity_type"], data["entity"]) if data["entity"] else None
        )
        return cls(entity=entity, corporation=corporation, minor=minor)

    def to_dict(self):
        return {
            "type": "merge",
            "entity": self.entity.id if self.entity else None,
            "entity_type": type_s(self.entity) if self.entity else None,
            "corporation": self.corporation.id if self.corporation else None,
            "minor": self.minor.id if self.minor else None,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 74
class MoveBid(BaseAction):
    def __init__(
        self, entity, price, from_company, from_price, company=None, corporation=None
    ):
        super().__init__(entity)
        self.company = company
        self.corporation = corporation
        self.price = price
        self.from_company = from_company
        self.from_price = from_price

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=None,
            company=game.company_by_id(data.get("company")),
            corporation=game.corporation_by_id(data.get("corporation")),
            from_company=game.company_by_id(data.get("from_company")),
            price=data.get("price"),
            from_price=data.get("from_price"),
        )

    def to_dict(self):
        return {
            "type": "move_bid",
            "company": self.company.id if self.company else None,
            "corporation": self.corporation.id if self.corporation else None,
            "price": self.price,
            "from_company": self.from_company.id if self.from_company else None,
            "from_price": self.from_price,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 76
class Offer(BaseAction):
    def __init__(self, entity, corporation=None, company=None, price=None):
        super().__init__(entity)
        self.corporation = corporation
        self.company = company
        self.price = price

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=None,
            corporation=game.corporation_by_id(data.get("corporation")),
            company=game.company_by_id(data.get("company")),
            price=data.get("price"),
        )

    def to_dict(self):
        return {
            "type": "offer",
            "corporation": self.corporation.id if self.corporation else None,
            "company": self.company.id if self.company else None,
            "price": self.price,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 78
class Par(BaseAction):
    def __init__(
        self,
        entity,
        corporation,
        share_price,
        slot=None,
        purchase_for=None,
        borrow_from=None,
    ):
        super().__init__(entity)
        self.corporation = corporation
        self.share_price = share_price
        self.slot = slot
        self.purchase_for = purchase_for
        self.borrow_from = borrow_from

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=None,
            corporation=game.corporation_by_id(data["corporation"]),
            share_price=game.share_price_by_id(data["share_price"]),
            slot=data.get("slot"),
            purchase_for=game.get(
                data.get("purchase_for_type"), data.get("purchase_for")
            ),
            borrow_from=game.get(data.get("borrow_from_type"), data.get("borrow_from")),
        )

    def to_dict(self):
        return {
            "type": "par",
            "corporation": self.corporation.id,
            "share_price": self.share_price.id,
            "slot": self.slot,
            "purchase_for_type": type_s(self.purchase_for),
            "purchase_for": self.purchase_for.id if self.purchase_for else None,
            "borrow_from_type": type_s(self.borrow_from),
            "borrow_from": self.borrow_from.id if self.borrow_from else None,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 80
class Pass(BaseAction):
    def pass_(self):
        return True

# %% ../../../nbs/game/engine/03_actions.ipynb 82
class PayoffDebt(BaseAction):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 84
class TakeLoan(BaseAction):
    def __init__(self, entity, loan):
        super().__init__(entity)
        self.loan = loan

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity_type"], data["entity"]),
            loan=game.get_loan(data["loan"]),
        )

    def to_dict(self):
        return {
            "type": "take_loan",
            "entity": self.entity.id,
            "entity_type": self.entity.type,
            "loan": self.loan.id if self.loan else None,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 86
class PayoffDebt(TakeLoan):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 88
class PayoffPlayerDebt(BaseAction):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 90
class PlaceToken(BaseAction):
    def __init__(self, entity, city, slot, cost=None, tokener=None, token_type=None):
        super().__init__(entity)
        self.city = city
        self.slot = slot
        self.cost = cost
        self.tokener = tokener
        token_owner = tokener or (entity.owner if entity.company else entity)
        self.token = token_owner.find_token_by_type(token_type) if token_type else None

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity_type"], data["entity"]),
            city=game.get_city(data["city"]),
            slot=data["slot"],
            cost=data["cost"],
            tokener=game.get_corporation(data["tokener"])
            or game.get_minor(data["tokener"]),
            token_type=data["token_type"],
        )

    def to_dict(self):
        return {
            "type": "place_token",
            "entity": self.entity.id,
            "entity_type": self.entity.type,
            "city": self.city.id,
            "slot": self.slot,
            "cost": self.cost,
            "tokener": self.tokener.id if self.tokener else None,
            "token_type": self.token.type
            if self.token and self.token.type != "normal"
            else None,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 92
class ProgramEnable(BaseAction):
    def disable(self, game):
        return True

# %% ../../../nbs/game/engine/03_actions.ipynb 94
class ProgramDisable(BaseAction):
    def __init__(self, entity, reason, original_type=None):
        super().__init__(entity)
        self.reason = reason
        self.original_type = original_type

    @classmethod
    def h_to_args(cls, h, _game):
        return {
            "reason": h["reason"],
            "original_type": h["original_type"],
        }

    def args_to_h(self):
        return {
            "reason": self.reason,
            "original_type": self.original_type,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 96
class ProgramAuctionBid(ProgramEnable):
    def __init__(
        self,
        entity,
        bid_target,
        maximum_bid,
        buy_price,
        enable_maximum_bid=False,
        enable_buy_price=False,
        auto_pass_after=False,
    ):
        super().__init__(entity)
        self.bid_target = bid_target
        self.enable_maximum_bid = enable_maximum_bid
        self.maximum_bid = maximum_bid
        self.enable_buy_price = enable_buy_price
        self.buy_price = buy_price
        self.auto_pass_after = auto_pass_after

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity_type"], data["entity"]),
            bid_target=game.get_corporation(data["bid_target"])
            or game.get_company(data["bid_target"])
            or game.get_minor(data["bid_target"]),
            enable_maximum_bid=data["enable_maximum_bid"],
            maximum_bid=data["maximum_bid"],
            enable_buy_price=data["enable_buy_price"],
            buy_price=data["buy_price"],
            auto_pass_after=data["auto_pass_after"],
        )

    def to_dict(self):
        return {
            "type": "program_auction_bid",
            "entity": self.entity.id,
            "entity_type": self.entity.type,
            "bid_target": self.bid_target.id,
            "enable_maximum_bid": self.enable_maximum_bid,
            "maximum_bid": self.maximum_bid,
            "enable_buy_price": self.enable_buy_price,
            "buy_price": self.buy_price,
            "auto_pass_after": self.auto_pass_after,
        }

    def __str__(self):
        buy = f"Buy if price at {self.buy_price}. " if self.enable_buy_price else ""
        bid = (
            f"Bid on {self.bid_target.name} up to {self.maximum_bid}. "
            if self.enable_maximum_bid
            else ""
        )
        suffix = "Otherwise auto pass." if self.auto_pass_after else ""

        return f"{buy}{bid}{suffix}"

    def disable(self, game):
        return not game.round.auction

# %% ../../../nbs/game/engine/03_actions.ipynb 98
class ProgramBuyShares(ProgramEnable):
    def __init__(
        self,
        entity,
        corporation,
        until_condition,
        from_market=False,
        auto_pass_after=False,
    ):
        super().__init__(entity)
        self.corporation = corporation
        self.until_condition = until_condition
        self.from_market = from_market
        self.auto_pass_after = auto_pass_after

    @classmethod
    def from_dict(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity_type"], data["entity"]),
            corporation=game.get_corporation(data["corporation"]),
            until_condition=data["until_condition"],
            from_market=data["from_market"],
            auto_pass_after=data["auto_pass_after"],
        )

    def to_dict(self):
        return {
            "type": "program_buy_shares",
            "entity": self.entity.id,
            "entity_type": self.entity.type,
            "corporation": self.corporation.id,
            "until_condition": self.until_condition,
            "from_market": self.from_market,
            "auto_pass_after": self.auto_pass_after,
        }

    def __str__(self):
        source = "market" if self.from_market else "IPO"
        condition = (
            "floated"
            if self.until_condition == "float"
            else f"{self.until_condition} shares"
        )
        suffix = ", then auto pass" if self.auto_pass_after else ""

        return f"Buy {self.corporation.name} from {source} until {condition}{suffix}"

    def disable(self, game):
        return not game.round.stock

# %% ../../../nbs/game/engine/03_actions.ipynb 100
class ProgramClosePass(ProgramEnable):
    def __init__(self, entity, unconditional=False):
        super().__init__(entity)
        self.unconditional = unconditional

    @classmethod
    def h_to_args(cls, h, _game):
        return {
            "unconditional": h["unconditional"],
        }

    def args_to_h(self):
        return {
            "unconditional": self.unconditional,
        }

    def to_s(self):
        unconditionally = ", unconditionally" if self.unconditional else ""
        return f"Pass in Closing Round{unconditionally}"

    def disable(self, _game):
        return False

# %% ../../../nbs/game/engine/03_actions.ipynb 102
class ProgramHarzbahnDraftPass(ProgramEnable):
    def __init__(self, entity, until_premium, unconditional):
        super().__init__(entity)
        self.until_premium = until_premium
        self.unconditional = unconditional

    @classmethod
    def h_to_args(cls, h, _game):
        return {
            "until_premium": h["until_premium"],
            "unconditional": h["unconditional"],
        }

    def args_to_h(self):
        return {
            "until_premium": self.until_premium,
            "unconditional": self.unconditional,
        }

    def to_s(self):
        until_premium = (
            f", until premium {self.until_premium}" if self.until_premium else ""
        )
        unconditionally = ", unconditionally" if self.unconditional else ""
        return f"Pass in Draft{until_premium}{unconditionally}"

    def disable(self, game):
        return not game.round.auction

# %% ../../../nbs/game/engine/03_actions.ipynb 104
class ProgramIndependentMines(ProgramEnable):
    def __init__(self, entity, skip_track, skip_buy, skip_close, indefinite):
        super().__init__(entity)
        self.skip_track = skip_track
        self.skip_buy = skip_buy
        self.skip_close = skip_close
        self.indefinite = indefinite

    @classmethod
    def h_to_args(cls, h, _game):
        return {
            "skip_track": h["skip_track"],
            "skip_buy": h["skip_buy"],
            "skip_close": h["skip_close"],
            "indefinite": h["indefinite"],
        }

    def args_to_h(self):
        return {
            "skip_track": self.skip_track,
            "skip_buy": self.skip_buy,
            "skip_close": self.skip_close,
            "indefinite": self.indefinite,
        }

    def to_s(self):
        steps = []
        if self.skip_track:
            steps.append("track")
        if self.skip_buy:
            steps.append("buy trains")
        if self.skip_close:
            steps.append("close")
        if not steps:
            steps.append("nothing?!")
        condition = "turned off" if self.indefinite else "next SR"
        return f"Pass ({','.join(steps)}) for independent mines until {condition}"

    def disable(self, game):
        return not (game.round.operating or self.indefinite)

# %% ../../../nbs/game/engine/03_actions.ipynb 106
class ProgramMergerPass(ProgramEnable):
    def __init__(self, entity, corporations_by_round, options):
        super().__init__(entity)
        self.corporations_by_round = corporations_by_round
        self.options = options

    @classmethod
    def h_to_args(cls, h, game):
        corporations_by_round = h.get("corporations_by_round", {})
        transformed_corps = {}
        for phase, corps_ids in corporations_by_round.items():
            corps_list = [game.corporation_by_id(c_id) for c_id in corps_ids]
            transformed_corps[phase] = corps_list
        return {
            "corporations_by_round": transformed_corps,
            "options": h.get("options", []),
        }

    def args_to_h(self):
        transformed_corps = {}
        for phase, corps_list in self.corporations_by_round.items():
            corps_ids = [corp.id for corp in corps_list]
            transformed_corps[phase] = corps_ids
        return {
            "corporations_by_round": transformed_corps,
            "options": self.options,
        }

    def to_s(self):
        phases = [
            f"{phase} ({', '.join(corp.name for corp in corps)})"
            if corps
            else f"{phase} (none)"
            for phase, corps in self.corporations_by_round.items()
        ]
        phases_str = " and ".join(phases)
        suffix = (
            ", unless someone else acts" if "disable_others" in self.options else ""
        )
        return f"Pass on mergers in {phases_str}{suffix}"

    def disable(self, game):
        return not game.round.merger

# %% ../../../nbs/game/engine/03_actions.ipynb 108
class ProgramSharePass(ProgramEnable):
    def __init__(self, entity, unconditional=False, indefinite=False):
        super().__init__(entity)
        self.unconditional = unconditional
        self.indefinite = indefinite

    @classmethod
    def h_to_args(cls, h, _game):
        return {
            "unconditional": h.get("unconditional", False),
            "indefinite": h.get("indefinite", False),
        }

    def args_to_h(self):
        return {
            "unconditional": self.unconditional,
            "indefinite": self.indefinite,
        }

    def to_s(self):
        unconditionally = ", unconditionally" if self.unconditional else ""
        indefinitely = ", indefinitely" if self.indefinite else ""
        return f"Pass in Stock Round{unconditionally}{indefinitely}"

    def disable(self, game):
        return not game.round.stock and not self.indefinite

# %% ../../../nbs/game/engine/03_actions.ipynb 110
class PurchaseTrain(BaseAction):
    pass

# %% ../../../nbs/game/engine/03_actions.ipynb 112
class ReassignTrains(BaseAction):
    def __init__(self, entity, assignments=None):
        super().__init__(entity)
        self.assignments = assignments if assignments else []

    @classmethod
    def h_to_args(cls, h, game):
        assignments = []
        for assignment in h.get("assignments", []):
            train = game.train_by_id(assignment["train"])
            corporation = game.corporation_by_id(assignment["corporation"])
            assignments.append({"train": train, "corporation": corporation})

        return {"assignments": assignments}

    def args_to_h(self):
        assignments = [
            {"train": item["train"].id, "corporation": item["corporation"].id}
            for item in self.assignments
        ]
        return {"assignments": assignments}

# %% ../../../nbs/game/engine/03_actions.ipynb 114
class Redo(BaseAction):
    def free(self):
        return True

# %% ../../../nbs/game/engine/03_actions.ipynb 116
class RemoveHexToken(BaseAction):
    def __init__(self, entity, hex):
        super().__init__(entity)
        self.hex = hex

    @classmethod
    def from_input(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity"]),
            hex=game.get_hex_by_id(data["hex"]),
        )

    def to_input(self):
        return {
            "type": "remove_hex_token",
            "entity": self.entity.id,
            "hex": self.hex.id,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 118
class RemoveToken(BaseAction):
    def __init__(self, entity, city, slot):
        super().__init__(entity)
        self.city = city
        self.slot = slot

    @classmethod
    def from_input(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity"]),
            city=game.get_city_by_id(data["city"]),
            slot=data["slot"],
        )

    def to_input(self):
        return {
            "type": "remove_token",
            "entity": self.entity.id,
            "city": self.city.id,
            "slot": self.slot,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 120
class Respond(BaseAction):
    def __init__(self, entity, corporation, company, accept):
        super().__init__(entity)
        self.corporation = corporation
        self.company = company
        self.accept = accept

    @classmethod
    def from_input(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity"]),
            corporation=game.get_corporation_by_id(data["corporation"]),
            company=game.get_company_by_id(data["company"]),
            accept=data["accept"] == "true",
        )

    def to_input(self):
        return {
            "type": "respond",
            "entity": self.entity.id,
            "corporation": self.corporation.id,
            "company": self.company.id,
            "accept": "true" if self.accept else "false",
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 122
class RunRoutes(BaseAction):
    def __init__(self, entity, routes, extra_revenue=0):
        super().__init__(entity)
        self.routes = routes
        self.extra_revenue = extra_revenue

    @classmethod
    def from_input(cls, data, game):
        routes = []

        for route_data in data["routes"]:
            route = Route.from_input(route_data, game)
            routes.append(route)

        return cls(
            entity=game.get_entity(data["entity"]),
            routes=routes,
            extra_revenue=data["extra_revenue"],
        )

    def to_input(self):
        routes_data = []
        for route in self.routes:
            route_data = route.to_input()
            routes_data.append(route_data)

        return {
            "type": "run_routes",
            "entity": self.entity.id,
            "routes": routes_data,
            "extra_revenue": self.extra_revenue,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 124
class ScrapTrain(BaseAction):
    def __init__(self, entity, train):
        super().__init__(entity)
        self.train = train

    @classmethod
    def from_input(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity"]),
            train=game.get_train(data["train"]),
        )

    def to_input(self):
        return {
            "type": "scrap_train",
            "entity": self.entity.id,
            "train": self.train.id,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 126
class SellCompany(BaseAction):
    def __init__(self, entity, company, price):
        super().__init__(entity)
        self.company = company
        self.price = price

    @classmethod
    def from_input(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity"]),
            company=game.get_company(data["company"]),
            price=data["price"],
        )

    def to_input(self):
        return {
            "type": "sell_company",
            "entity": self.entity.id,
            "company": self.company.id,
            "price": self.price,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 128
class Short(BaseAction):
    def __init__(self, entity, corporation):
        super().__init__(entity)
        self.corporation = corporation

    @classmethod
    def from_input(cls, data, game):
        return cls(
            entity=game.get_entity(data["entity"]),
            corporation=game.get_corporation(data["corporation"]),
        )

    def to_input(self):
        return {
            "type": "short",
            "entity": self.entity.id,
            "corporation": self.corporation.id,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 130
class SpecialBuy(BaseAction):
    def __init__(self, entity, item):
        super().__init__(entity)
        self.item = item

    @classmethod
    def from_input(cls, data, _game):
        item_data = data.get("item", {})
        item = Item(
            description=item_data.get("description", ""),
            cost=item_data.get("cost", 0),
        )
        return cls(entity=data["entity"], item=item)

    def to_input(self):
        return {
            "type": "special_buy",
            "entity": self.entity.id,
            "item": {
                "description": self.item.description,
                "cost": self.item.cost,
            },
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 132
class Split(BaseAction):
    def __init__(self, entity, corporation):
        super().__init__(entity)
        self.corporation = corporation

    @classmethod
    def from_input(cls, data, game):
        return cls(
            entity=data["entity"],
            corporation=game.corporation_by_id(data["corporation"]),
        )

    def to_input(self):
        return {
            "type": "split",
            "entity": self.entity.id,
            "corporation": self.corporation.id,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 134
class SwapTrain(BaseAction):
    def __init__(self, entity, train):
        super().__init__(entity)
        self.train = train

    @classmethod
    def from_input(cls, data, game):
        return cls(
            entity=data["entity"],
            train=game.train_by_id(data["train"]),
        )

    def to_input(self):
        return {
            "type": "swap_train",
            "entity": self.entity.id,
            "train": self.train.id,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 136
class SwitchTrains(BaseAction):
    def __init__(self, entity, slots=None):
        super().__init__(entity)
        self.slots = slots

    @classmethod
    def from_input(cls, data, _game):
        return cls(
            entity=data["entity"],
            slots=[int(slot) for slot in data.get("slots", [])],
        )

    def to_input(self):
        return {
            "type": "switch_trains",
            "entity": self.entity.id,
            "slots": self.slots,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 138
class Undo(BaseAction):
    def __init__(self, entity, action_id=None):
        super().__init__(entity)
        self.action_id = action_id

    @classmethod
    def from_input(cls, data, _game):
        return cls(
            entity=data["entity"],
            action_id=data.get("action_id"),
        )

    def to_input(self):
        return {
            "type": "undo",
            "entity": self.entity.id,
            "action_id": self.action_id,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 140
class UseGraph(BaseAction):
    def __init__(self, entity, graph_id):
        super().__init__(entity)
        self.graph_id = graph_id

    @classmethod
    def from_input(cls, data, _game):
        return cls(
            entity=data["entity"],
            graph_id=data["graph_id"],
        )

    def to_input(self):
        return {
            "type": "use_graph",
            "entity": self.entity.id,
            "graph_id": self.graph_id,
        }

# %% ../../../nbs/game/engine/03_actions.ipynb 142
class ViewMergeOptions(BaseAction):
    pass
